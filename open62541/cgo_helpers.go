// Mozilla Public License Version 2.0

// WARNING: This file has automatically been generated on Fri, 17 Jan 2020 22:57:19 MSK.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package open62541

/*
#cgo LDFLAGS: -lopen62541
#include "open62541/architecture_base.h"
#include "open62541/architecture_definitions.h"
#include "open62541/architecture_functions.h"
#include "open62541/client_config_default.h"
#include "open62541/client_config.h"
#include "open62541/client.h"
#include "open62541/client_highlevel_async.h"
#include "open62541/client_highlevel.h"
#include "open62541/client_subscriptions.h"
#include "open62541/config.h"
#include "open62541/constants.h"
#include "open62541/ms_stdint.h"
#include "open62541/network_tcp.h"
#include "open62541/nodeids.h"
#include "open62541/server_config_default.h"
#include "open62541/server_config.h"
#include "open62541/server.h"
#include "open62541/server_pubsub.h"
#include "open62541/statuscodes.h"
#include "open62541/types_generated.h"
#include "open62541/types_generated_handling.h"
#include "open62541/types.h"
#include "open62541/util.h"
#include "open62541/ziptree.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocServerConfigMemory allocates memory for type C.UA_ServerConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocServerConfigMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfServerConfigValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfServerConfigValue = unsafe.Sizeof([1]C.UA_ServerConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ServerConfig) Ref() *C.UA_ServerConfig {
	if x == nil {
		return nil
	}
	return x.ref2fa14d5
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ServerConfig) Free() {
	if x != nil && x.allocs2fa14d5 != nil {
		x.allocs2fa14d5.(*cgoAllocMap).Free()
		x.ref2fa14d5 = nil
	}
}

// NewServerConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewServerConfigRef(ref unsafe.Pointer) *ServerConfig {
	if ref == nil {
		return nil
	}
	obj := new(ServerConfig)
	obj.ref2fa14d5 = (*C.UA_ServerConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ServerConfig) PassRef() (*C.UA_ServerConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2fa14d5 != nil {
		return x.ref2fa14d5, nil
	}
	mem2fa14d5 := allocServerConfigMemory(1)
	ref2fa14d5 := (*C.UA_ServerConfig)(mem2fa14d5)
	allocs2fa14d5 := new(cgoAllocMap)
	allocs2fa14d5.Add(mem2fa14d5)

	var cnThreads_allocs *cgoAllocMap
	ref2fa14d5.nThreads, cnThreads_allocs = (C.UA_UInt16)(x.NThreads), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cnThreads_allocs)

	var cserverCertificate_allocs *cgoAllocMap
	ref2fa14d5.serverCertificate, cserverCertificate_allocs = x.ServerCertificate.PassValue()
	allocs2fa14d5.Borrow(cserverCertificate_allocs)

	var cshutdownDelay_allocs *cgoAllocMap
	ref2fa14d5.shutdownDelay, cshutdownDelay_allocs = (C.UA_Double)(x.ShutdownDelay), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cshutdownDelay_allocs)

	var cnetworkLayersSize_allocs *cgoAllocMap
	ref2fa14d5.networkLayersSize, cnetworkLayersSize_allocs = (C.size_t)(x.NetworkLayersSize), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cnetworkLayersSize_allocs)

	var csecurityPoliciesSize_allocs *cgoAllocMap
	ref2fa14d5.securityPoliciesSize, csecurityPoliciesSize_allocs = (C.size_t)(x.SecurityPoliciesSize), cgoAllocsUnknown
	allocs2fa14d5.Borrow(csecurityPoliciesSize_allocs)

	var cendpointsSize_allocs *cgoAllocMap
	ref2fa14d5.endpointsSize, cendpointsSize_allocs = (C.size_t)(x.EndpointsSize), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cendpointsSize_allocs)

	var crelaxEmptyValueConstraint_allocs *cgoAllocMap
	ref2fa14d5.relaxEmptyValueConstraint, crelaxEmptyValueConstraint_allocs = (C.UA_Boolean)(x.RelaxEmptyValueConstraint), cgoAllocsUnknown
	allocs2fa14d5.Borrow(crelaxEmptyValueConstraint_allocs)

	var cmaxSecureChannels_allocs *cgoAllocMap
	ref2fa14d5.maxSecureChannels, cmaxSecureChannels_allocs = (C.UA_UInt16)(x.MaxSecureChannels), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSecureChannels_allocs)

	var cmaxSecurityTokenLifetime_allocs *cgoAllocMap
	ref2fa14d5.maxSecurityTokenLifetime, cmaxSecurityTokenLifetime_allocs = (C.UA_UInt32)(x.MaxSecurityTokenLifetime), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSecurityTokenLifetime_allocs)

	var cmaxSessions_allocs *cgoAllocMap
	ref2fa14d5.maxSessions, cmaxSessions_allocs = (C.UA_UInt16)(x.MaxSessions), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSessions_allocs)

	var cmaxSessionTimeout_allocs *cgoAllocMap
	ref2fa14d5.maxSessionTimeout, cmaxSessionTimeout_allocs = (C.UA_Double)(x.MaxSessionTimeout), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSessionTimeout_allocs)

	var cmaxNodesPerRead_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerRead, cmaxNodesPerRead_allocs = (C.UA_UInt32)(x.MaxNodesPerRead), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerRead_allocs)

	var cmaxNodesPerWrite_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerWrite, cmaxNodesPerWrite_allocs = (C.UA_UInt32)(x.MaxNodesPerWrite), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerWrite_allocs)

	var cmaxNodesPerMethodCall_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerMethodCall, cmaxNodesPerMethodCall_allocs = (C.UA_UInt32)(x.MaxNodesPerMethodCall), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerMethodCall_allocs)

	var cmaxNodesPerBrowse_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerBrowse, cmaxNodesPerBrowse_allocs = (C.UA_UInt32)(x.MaxNodesPerBrowse), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerBrowse_allocs)

	var cmaxNodesPerRegisterNodes_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerRegisterNodes, cmaxNodesPerRegisterNodes_allocs = (C.UA_UInt32)(x.MaxNodesPerRegisterNodes), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerRegisterNodes_allocs)

	var cmaxNodesPerTranslateBrowsePathsToNodeIds_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerTranslateBrowsePathsToNodeIds, cmaxNodesPerTranslateBrowsePathsToNodeIds_allocs = (C.UA_UInt32)(x.MaxNodesPerTranslateBrowsePathsToNodeIds), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerTranslateBrowsePathsToNodeIds_allocs)

	var cmaxNodesPerNodeManagement_allocs *cgoAllocMap
	ref2fa14d5.maxNodesPerNodeManagement, cmaxNodesPerNodeManagement_allocs = (C.UA_UInt32)(x.MaxNodesPerNodeManagement), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNodesPerNodeManagement_allocs)

	var cmaxMonitoredItemsPerCall_allocs *cgoAllocMap
	ref2fa14d5.maxMonitoredItemsPerCall, cmaxMonitoredItemsPerCall_allocs = (C.UA_UInt32)(x.MaxMonitoredItemsPerCall), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxMonitoredItemsPerCall_allocs)

	var cmaxReferencesPerNode_allocs *cgoAllocMap
	ref2fa14d5.maxReferencesPerNode, cmaxReferencesPerNode_allocs = (C.UA_UInt32)(x.MaxReferencesPerNode), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxReferencesPerNode_allocs)

	var cmaxSubscriptions_allocs *cgoAllocMap
	ref2fa14d5.maxSubscriptions, cmaxSubscriptions_allocs = (C.UA_UInt32)(x.MaxSubscriptions), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSubscriptions_allocs)

	var cmaxSubscriptionsPerSession_allocs *cgoAllocMap
	ref2fa14d5.maxSubscriptionsPerSession, cmaxSubscriptionsPerSession_allocs = (C.UA_UInt32)(x.MaxSubscriptionsPerSession), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxSubscriptionsPerSession_allocs)

	var cmaxNotificationsPerPublish_allocs *cgoAllocMap
	ref2fa14d5.maxNotificationsPerPublish, cmaxNotificationsPerPublish_allocs = (C.UA_UInt32)(x.MaxNotificationsPerPublish), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxNotificationsPerPublish_allocs)

	var cenableRetransmissionQueue_allocs *cgoAllocMap
	ref2fa14d5.enableRetransmissionQueue, cenableRetransmissionQueue_allocs = (C.UA_Boolean)(x.EnableRetransmissionQueue), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cenableRetransmissionQueue_allocs)

	var cmaxRetransmissionQueueSize_allocs *cgoAllocMap
	ref2fa14d5.maxRetransmissionQueueSize, cmaxRetransmissionQueueSize_allocs = (C.UA_UInt32)(x.MaxRetransmissionQueueSize), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxRetransmissionQueueSize_allocs)

	var cmaxMonitoredItems_allocs *cgoAllocMap
	ref2fa14d5.maxMonitoredItems, cmaxMonitoredItems_allocs = (C.UA_UInt32)(x.MaxMonitoredItems), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxMonitoredItems_allocs)

	var cmaxMonitoredItemsPerSubscription_allocs *cgoAllocMap
	ref2fa14d5.maxMonitoredItemsPerSubscription, cmaxMonitoredItemsPerSubscription_allocs = (C.UA_UInt32)(x.MaxMonitoredItemsPerSubscription), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxMonitoredItemsPerSubscription_allocs)

	var cmaxPublishReqPerSession_allocs *cgoAllocMap
	ref2fa14d5.maxPublishReqPerSession, cmaxPublishReqPerSession_allocs = (C.UA_UInt32)(x.MaxPublishReqPerSession), cgoAllocsUnknown
	allocs2fa14d5.Borrow(cmaxPublishReqPerSession_allocs)

	// var cmonitoredItemRegisterCallback_allocs *cgoAllocMap
	// ref2fa14d5.monitoredItemRegisterCallback, cmonitoredItemRegisterCallback_allocs = x.MonitoredItemRegisterCallback.PassRef()
	// allocs2fa14d5.Borrow(cmonitoredItemRegisterCallback_allocs)

	x.ref2fa14d5 = ref2fa14d5
	x.allocs2fa14d5 = allocs2fa14d5
	return ref2fa14d5, allocs2fa14d5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ServerConfig) PassValue() (C.UA_ServerConfig, *cgoAllocMap) {
	if x.ref2fa14d5 != nil {
		return *x.ref2fa14d5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ServerConfig) Deref() {
	if x.ref2fa14d5 == nil {
		return
	}
	x.NThreads = (uint16)(x.ref2fa14d5.nThreads)
	x.ServerCertificate = *NewByteStringRef(unsafe.Pointer(&x.ref2fa14d5.serverCertificate))
	x.ShutdownDelay = (float64)(x.ref2fa14d5.shutdownDelay)
	x.NetworkLayersSize = (uint)(x.ref2fa14d5.networkLayersSize)
	x.SecurityPoliciesSize = (uint)(x.ref2fa14d5.securityPoliciesSize)
	x.EndpointsSize = (uint)(x.ref2fa14d5.endpointsSize)
	x.RelaxEmptyValueConstraint = (bool)(x.ref2fa14d5.relaxEmptyValueConstraint)
	x.MaxSecureChannels = (uint16)(x.ref2fa14d5.maxSecureChannels)
	x.MaxSecurityTokenLifetime = (uint32)(x.ref2fa14d5.maxSecurityTokenLifetime)
	x.MaxSessions = (uint16)(x.ref2fa14d5.maxSessions)
	x.MaxSessionTimeout = (float64)(x.ref2fa14d5.maxSessionTimeout)
	x.MaxNodesPerRead = (uint32)(x.ref2fa14d5.maxNodesPerRead)
	x.MaxNodesPerWrite = (uint32)(x.ref2fa14d5.maxNodesPerWrite)
	x.MaxNodesPerMethodCall = (uint32)(x.ref2fa14d5.maxNodesPerMethodCall)
	x.MaxNodesPerBrowse = (uint32)(x.ref2fa14d5.maxNodesPerBrowse)
	x.MaxNodesPerRegisterNodes = (uint32)(x.ref2fa14d5.maxNodesPerRegisterNodes)
	x.MaxNodesPerTranslateBrowsePathsToNodeIds = (uint32)(x.ref2fa14d5.maxNodesPerTranslateBrowsePathsToNodeIds)
	x.MaxNodesPerNodeManagement = (uint32)(x.ref2fa14d5.maxNodesPerNodeManagement)
	x.MaxMonitoredItemsPerCall = (uint32)(x.ref2fa14d5.maxMonitoredItemsPerCall)
	x.MaxReferencesPerNode = (uint32)(x.ref2fa14d5.maxReferencesPerNode)
	x.MaxSubscriptions = (uint32)(x.ref2fa14d5.maxSubscriptions)
	x.MaxSubscriptionsPerSession = (uint32)(x.ref2fa14d5.maxSubscriptionsPerSession)
	x.MaxNotificationsPerPublish = (uint32)(x.ref2fa14d5.maxNotificationsPerPublish)
	x.EnableRetransmissionQueue = (bool)(x.ref2fa14d5.enableRetransmissionQueue)
	x.MaxRetransmissionQueueSize = (uint32)(x.ref2fa14d5.maxRetransmissionQueueSize)
	x.MaxMonitoredItems = (uint32)(x.ref2fa14d5.maxMonitoredItems)
	x.MaxMonitoredItemsPerSubscription = (uint32)(x.ref2fa14d5.maxMonitoredItemsPerSubscription)
	x.MaxPublishReqPerSession = (uint32)(x.ref2fa14d5.maxPublishReqPerSession)
	// x.MonitoredItemRegisterCallback = NewRef(unsafe.Pointer(x.ref2fa14d5.monitoredItemRegisterCallback))
}

// Ref returns a reference to C object as it is.
func (x *Server) Ref() *C.UA_Server {
	if x == nil {
		return nil
	}
	return (*C.UA_Server)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Server) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewServerRef converts the C object reference into a raw struct reference without wrapping.
func NewServerRef(ref unsafe.Pointer) *Server {
	return (*Server)(ref)
}

// NewServer allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewServer() *Server {
	return (*Server)(allocServerMemory(1))
}

// allocServerMemory allocates memory for type C.UA_Server in C.
// The caller is responsible for freeing the this memory via C.free.
func allocServerMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfServerValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfServerValue = unsafe.Sizeof([1]C.UA_Server{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Server) PassRef() *C.UA_Server {
	if x == nil {
		x = (*Server)(allocServerMemory(1))
	}
	return (*C.UA_Server)(unsafe.Pointer(x))
}

// allocStringMemory allocates memory for type C.UA_String in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStringMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStringValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStringValue = unsafe.Sizeof([1]C.UA_String{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ByteString) Ref() *C.UA_String {
	if x == nil {
		return nil
	}
	return x.refc6b65d86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ByteString) Free() {
	if x != nil && x.allocsc6b65d86 != nil {
		x.allocsc6b65d86.(*cgoAllocMap).Free()
		x.refc6b65d86 = nil
	}
}

// NewByteStringRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewByteStringRef(ref unsafe.Pointer) *ByteString {
	if ref == nil {
		return nil
	}
	obj := new(ByteString)
	obj.refc6b65d86 = (*C.UA_String)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ByteString) PassRef() (*C.UA_String, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc6b65d86 != nil {
		return x.refc6b65d86, nil
	}
	memc6b65d86 := allocStringMemory(1)
	refc6b65d86 := (*C.UA_String)(memc6b65d86)
	allocsc6b65d86 := new(cgoAllocMap)
	allocsc6b65d86.Add(memc6b65d86)

	var clength_allocs *cgoAllocMap
	refc6b65d86.length, clength_allocs = (C.size_t)(x.Length), cgoAllocsUnknown
	allocsc6b65d86.Borrow(clength_allocs)

	var cdata_allocs *cgoAllocMap
	refc6b65d86.data, cdata_allocs = (*C.UA_Byte)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Data)).Data)), cgoAllocsUnknown
	allocsc6b65d86.Borrow(cdata_allocs)

	x.refc6b65d86 = refc6b65d86
	x.allocsc6b65d86 = allocsc6b65d86
	return refc6b65d86, allocsc6b65d86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ByteString) PassValue() (C.UA_String, *cgoAllocMap) {
	if x.refc6b65d86 != nil {
		return *x.refc6b65d86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ByteString) Deref() {
	if x.refc6b65d86 == nil {
		return
	}
	x.Length = (uint)(x.refc6b65d86.length)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Data))
	hxfc4425b.Data = unsafe.Pointer(x.refc6b65d86.data)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

}

// allocNodeIdMemory allocates memory for type C.UA_NodeId in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNodeIdMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNodeIdValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNodeIdValue = unsafe.Sizeof([1]C.UA_NodeId{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NodeId) Ref() *C.UA_NodeId {
	if x == nil {
		return nil
	}
	return x.ref516af8a8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NodeId) Free() {
	if x != nil && x.allocs516af8a8 != nil {
		x.allocs516af8a8.(*cgoAllocMap).Free()
		x.ref516af8a8 = nil
	}
}

// NewNodeIdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNodeIdRef(ref unsafe.Pointer) *NodeId {
	if ref == nil {
		return nil
	}
	obj := new(NodeId)
	obj.ref516af8a8 = (*C.UA_NodeId)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NodeId) PassRef() (*C.UA_NodeId, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref516af8a8 != nil {
		return x.ref516af8a8, nil
	}
	mem516af8a8 := allocNodeIdMemory(1)
	ref516af8a8 := (*C.UA_NodeId)(mem516af8a8)
	allocs516af8a8 := new(cgoAllocMap)
	allocs516af8a8.Add(mem516af8a8)

	var cnamespaceIndex_allocs *cgoAllocMap
	ref516af8a8.namespaceIndex, cnamespaceIndex_allocs = (C.UA_UInt16)(x.NamespaceIndex), cgoAllocsUnknown
	allocs516af8a8.Borrow(cnamespaceIndex_allocs)

	x.ref516af8a8 = ref516af8a8
	x.allocs516af8a8 = allocs516af8a8
	return ref516af8a8, allocs516af8a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NodeId) PassValue() (C.UA_NodeId, *cgoAllocMap) {
	if x.ref516af8a8 != nil {
		return *x.ref516af8a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *NodeId) Deref() {
	if x.ref516af8a8 == nil {
		return
	}
	x.NamespaceIndex = (uint16)(x.ref516af8a8.namespaceIndex)
}
